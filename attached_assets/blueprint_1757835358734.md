# Hackathon Management App — implementation blueprint

---

# MVP (what to build first)

Focus on the smallest useful product that solves team discovery + hackathon participation.

**MVP features**

1. User account: signup/login, profile (bio, skills, domains, preferred roles)
2. Discover page: list of hackathons, apply/join (individual or team), search/filter by skills/role
3. My Hackathons: join hackathon, see team / join teams, basic team chat
4. Hackathon rounds: submit repo/link, simple submit form
5. Leaderboard & basic scoring (team-based + individual contribution score)

Build iteratively: Auth → Profiles → Discover → Join/Teams → Submissions → Scoring → Chat.

---

# Suggested tech stack (simple, modern, low-friction)

- Frontend: React + Vite, TypeScript, TailwindCSS, React Router
- Backend: FastAPI (Python) or Node + Express. (I’ll show examples in FastAPI.)
- Database: PostgreSQL (production). SQLite for local/dev (MVP).
- Realtime (chat/notifications): WebSocket via FastAPI / Socket.IO (Node) or Pusher for managed.
- Storage: S3-compatible (for attachments) — use local file storage for MVP.
- Auth: JWT (access + refresh). Social login optional.
- Devops: Docker + GitHub Actions, Railway / Render for quick deploy.

---

# Project layout (recommended)

```
/hackathon-app
├─ backend/
│  ├─ app/
│  │  ├─ main.py
│  │  ├─ api/
│  │  │  ├─ v1/
│  │  │  │  ├─ auth.py
│  │  │  │  ├─ users.py
│  │  │  │  ├─ hackathons.py
│  │  │  │  ├─ teams.py
│  │  │  │  ├─ submissions.py
│  │  │  │  └─ scoring.py
│  │  ├─ core/
│  │  │  ├─ config.py
│  │  │  └─ security.py
│  │  ├─ models/
│  │  │  └─ orm_models.py
│  │  ├─ schemas/
│  │  │  └─ pydantic_models.py
│  │  ├─ db/
│  │  │  ├─ base.py
│  │  │  └─ crud.py
│  │  └─ services/
│  │     ├─ matchmaking.py
│  │     └─ scoring.py
│  └─ Dockerfile
├─ frontend/
│  ├─ src/
│  │  ├─ App.tsx
│  │  ├─ main.tsx
│  │  ├─ pages/
│  │  │  ├─ Home.tsx
│  │  │  ├─ Discover.tsx
│  │  │  ├─ MyHackathons/
│  │  │  │  ├─ Index.tsx
│  │  │  │  ├─ HackathonPage.tsx
│  │  │  │  └─ TeamChat.tsx
│  │  │  ├─ Profile.tsx
│  │  │  └─ Login.tsx
│  │  ├─ components/
│  │  │  ├─ HackathonCard.tsx
│  │  │  ├─ UserCard.tsx
│  │  │  └─ Leaderboard.tsx
│  │  └─ services/
│  │     └─ api.ts
│  └─ package.json
└─ README.md
```

---

# Database schema (Postgres - core tables)

Below is a normalized schema for core use-cases.

```sql
-- users
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email TEXT UNIQUE NOT NULL,
  password_hash TEXT,
  display_name TEXT,
  bio TEXT,
  location TEXT,
  created_at TIMESTAMPTZ DEFAULT now()
);

-- user_skills (many-to-many)
CREATE TABLE skills (
  id SERIAL PRIMARY KEY,
  name TEXT UNIQUE NOT NULL
);

CREATE TABLE user_skills (
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  skill_id INT REFERENCES skills(id) ON DELETE CASCADE,
  level SMALLINT, -- 1-5
  PRIMARY KEY (user_id, skill_id)
);

-- hackathons
CREATE TABLE hackathons (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  title TEXT,
  description TEXT,
  start_at TIMESTAMPTZ,
  end_at TIMESTAMPTZ,
  created_by UUID REFERENCES users(id),
  created_at TIMESTAMPTZ DEFAULT now(),
  is_public BOOLEAN DEFAULT true
);

-- hackathon_roles (domains/skill tags)
CREATE TABLE hackathon_tags (
  id SERIAL PRIMARY KEY,
  name TEXT UNIQUE NOT NULL
);
CREATE TABLE hackathon_tag_map (
  hackathon_id UUID REFERENCES hackathons(id),
  tag_id INT REFERENCES hackathon_tags(id),
  PRIMARY KEY(hackathon_id, tag_id)
);

-- teams
CREATE TABLE teams (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  hackathon_id UUID REFERENCES hackathons(id) ON DELETE CASCADE,
  name TEXT,
  created_by UUID REFERENCES users(id),
  created_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE team_members (
  team_id UUID REFERENCES teams(id) ON DELETE CASCADE,
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  role TEXT,
  contribution_score FLOAT DEFAULT 0,
  joined_at TIMESTAMPTZ DEFAULT now(),
  PRIMARY KEY(team_id, user_id)
);

-- applications (individual/team)
CREATE TABLE applications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  hackathon_id UUID REFERENCES hackathons(id) ON DELETE CASCADE,
  applicant_user UUID REFERENCES users(id),
  team_id UUID REFERENCES teams(id),
  status TEXT DEFAULT 'pending', -- pending/accepted/rejected
  created_at TIMESTAMPTZ DEFAULT now()
);

-- submissions (rounds)
CREATE TABLE rounds (
  id SERIAL PRIMARY KEY,
  hackathon_id UUID REFERENCES hackathons(id),
  name TEXT,
  due_at TIMESTAMPTZ
);

CREATE TABLE submissions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  round_id INT REFERENCES rounds(id),
  team_id UUID REFERENCES teams(id),
  submitter UUID REFERENCES users(id),
  repo_url TEXT,
  live_url TEXT,
  notes TEXT,
  created_at TIMESTAMPTZ DEFAULT now()
);

-- evaluations
CREATE TABLE evaluations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  submission_id UUID REFERENCES submissions(id),
  judge_id UUID REFERENCES users(id),
  score FLOAT,
  comments TEXT,
  created_at TIMESTAMPTZ DEFAULT now()
);
```

---

# API design (RESTful endpoints — v1)

Use these to scaffold backend quickly. Indicate routes + payloads.

**Auth**

- `POST /api/v1/auth/signup` — {email, password, display_name}
- `POST /api/v1/auth/login` — {email, password} → {access_token, refresh_token}
- `POST /api/v1/auth/refresh` — {refresh_token}

**Users**

- `GET /api/v1/users/me` — get profile
- `PUT /api/v1/users/me` — update profile
- `GET /api/v1/users/:id` — public profile

**Skills / Tags**

- `GET /api/v1/skills`
- `POST /api/v1/skills` — admin

**Hackathons**

- `GET /api/v1/hackathons` — filters: tags, active, search, page
- `GET /api/v1/hackathons/:id`
- `POST /api/v1/hackathons` — create
- `PUT /api/v1/hackathons/:id`

**Teams / Applications**

- `POST /api/v1/hackathons/:id/apply` — {type: "individual"|"team", team_name?, role?, user_ids?}
- `POST /api/v1/hackathons/:id/teams` — create team
- `GET /api/v1/hackathons/:id/teams`
- `POST /api/v1/teams/:id/join` — request to join team
- `POST /api/v1/teams/:id/invite` — invite user

**Submissions & Rounds**

- `GET /api/v1/hackathons/:id/rounds`
- `POST /api/v1/rounds/:id/submissions` — {team_id, repo_url, live_url, notes}
- `GET /api/v1/submissions/:id` — view

**Scoring & Leaderboard**

- `POST /api/v1/submissions/:id/evaluate` — {judge_id, score, comments}
- `GET /api/v1/hackathons/:id/leaderboard` — aggregated scores

**Chat / Real-time**

- WebSocket endpoint: `/ws/hackathons/:id/chat` (authenticate with token)

---

# Example FastAPI route snippet (file path)

`backend/app/api/v1/hackathons.py`

```py
from fastapi import APIRouter, Depends
from app.schemas import HackathonCreate, HackathonOut
from app.db import get_db
router = APIRouter(prefix="/hackathons", tags=["hackathons"])

@router.get("/", response_model=List[HackathonOut])
def list_hackathons(q: str = None, db=Depends(get_db)):
    return db.list_hackathons(search=q)
```

(Path: `backend/app/api/v1/hackathons.py`)

---

# Frontend routes & components (file paths + brief responsibilities)

```
frontend/src/pages/Home.tsx          -- landing, trending hackathons
frontend/src/pages/Discover.tsx      -- search + filter + apply buttons
frontend/src/pages/MyHackathons/Index.tsx  -- list of joined hackathons
frontend/src/pages/MyHackathons/HackathonPage.tsx -- per-hackathon dashboard (tabs: team, rounds, submissions, leaderboard)
frontend/src/pages/MyHackathons/TeamChat.tsx -- chat UI (ws)
frontend/src/pages/Profile.tsx       -- profile view/edit (skills, roles)
frontend/src/components/HackathonCard.tsx -- used in Home/Discover
frontend/src/services/api.ts         -- axios wrapper + token management
```

Important: when creating API calls, centralize path config in `frontend/src/config/api.ts`:

```ts
export const API_BASE =
  import.meta.env.VITE_API_BASE || "http://localhost:8000/api/v1";
```

---

# Team matching algorithm (simple, for MVP)

Goal: find complementary teammates based on skills & roles.

1. Input: seeker_skills (list + levels), desired_role, hackathon_id, optional filters.
2. For each candidate user:

   - compute skill overlap score = sum(min(user_skill_level, seeker_need_level) for matched skills)
   - compute complementary_score = number of desired skills candidate has that seeker lacks
   - location/timezone compatibility boolean
   - availability tag match

3. Final match score = w1 \* complementary_score + w2 \* (1 - overlap_score_norm) + w3 \* activity_score

   - choose weighting (e.g., w1=0.6, w2=0.2, w3=0.2)

4. Return ranked list (top N) with reason badges: "Front-end", "ML", "Backend", "Designer"

Implement in `backend/app/services/matchmaking.py`.

---

# Scoring / contribution model

Two-part scoring:

- Judge scores (submission evaluations): average of judge scores per submission
- Peer contribution: team members rate contribution (0–10), stored in `team_members.contribution_score`
- Individual final score = α \* judge_score + β \* peer_contribution (α=0.75, β=0.25) — tunable.

Leaderboard aggregation:

- Team score = average of latest round weighted scores (round importance weight).
- Individual leaderboard derived from team scores \* individual's contribution weight.

Implement scoring in `backend/app/services/scoring.py`.

---

# Permissions model

- Roles: `user`, `organizer`, `judge`, `admin`.
- Access control:

  - `organizer` can create hackathons, add rounds, view applications.
  - `judge` can evaluate submissions for assigned hackathons.
  - `user` can apply, create/join teams, submit.

- Implementation: store roles in `users.roles` (array) or separate table `user_roles`.

Auth middleware verifies JWT and role claims. Put decorators like `@requires_role("organizer")`.

---

# Team chat (MVP)

- Use WebSocket channel per hackathon or per team.
- Endpoint: `/ws/teams/:team_id` or `/ws/hackathons/:hackathon_id`.
- Messages include: `{id, sender_id, text, timestamp, type}`.
- Persist messages to DB for history (optional for MVP — keep in-memory / Redis for scale).

---

# UX notes / screens (quick)

1. Home: hero + trending hackathons (cards) + CTA "Discover"
2. Discover: search bar (skills/role), filters (active/online/remote), results with "Apply/Join Team" buttons
3. Hackathon page: top banner, tabs: Overview | Teams | Rounds | Leaderboard | Chat
4. Team card: members, roles, join request button, “message” button
5. Profile edit modal: add skills (autocomplete), role preference, short bio
6. Apply modal: choose individual/team, select/create team, note for organizers

---

# Testing & QA

- Backend: unit tests for matchmaking + scoring; integration tests for endpoints (pytest + test DB)
- Frontend: component tests (Vitest/React Testing Library), E2E with Playwright
- Security: test JWT expiry, role escalation attempts, file upload size/type checks
- Performance: pagination on hackathon lists, indexing DB fields (email, hackathon.start_at, tags)

---

# Deployment checklist

1. Containerize backend & frontend (Dockerfiles).
2. Use environment variables for secrets (DB, JWT secret).
3. CI: build + run tests + push to registry.
4. Managed DB (Postgres), S3 storage.
5. Add domain + HTTPS.
6. Monitoring (Sentry / basic health endpoint).

---

# Starter priorities & 2-week sprint plan (example)

Week 1:

- Day 1–2: Setup repo + auth (signup/login + JWT)
- Day 3–4: User profile CRUD + skills
- Day 5: Hackathon model + list + create
  Week 2:
- Day 6–7: Discover page + filters
- Day 8–9: Team create/join + applications
- Day 10: Submissions + simple leaderboard
- Day 11–12: Basic chat (WebSocket) + polish
- Day 13–14: Tests + deploy to dev

---

# Extras / nice-to-have (post-MVP)

- AI recommendations for team formation (embedding-based)
- Contribution tracking via commit/repo analysis (GitHub integration)
- Rich media submissions (video)
- Awards + certificates generation (PDF)
- Mobile-first styling, PWA support

---
